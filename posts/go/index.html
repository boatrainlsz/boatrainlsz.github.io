<!doctype html><html lang=zh-cn><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=robots content="noodp"><meta http-equiv=x-ua-compatible content="IE=edge, chrome=1"><title>基于寄存器调用惯例的Go语言接口调用机制 - boatrain的博客</title><meta name=Description content><meta property="og:title" content="基于寄存器调用惯例的Go语言接口调用机制"><meta property="og:description" content="本文是对此文章的学习与翻译。 摘要 其实这个机制和Java以及C++的接口调用机制差不多，都是基于itable，不过Java由于虚拟机规范中没有"><meta property="og:type" content="article"><meta property="og:url" content="https://boatrainlsz.github.io/posts/go/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-04-02T21:35:40+08:00"><meta property="article:modified_time" content="2022-04-02T21:35:40+08:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="基于寄存器调用惯例的Go语言接口调用机制"><meta name=twitter:description content="本文是对此文章的学习与翻译。 摘要 其实这个机制和Java以及C++的接口调用机制差不多，都是基于itable，不过Java由于虚拟机规范中没有"><meta name=application-name content="boatrain的博客"><meta name=apple-mobile-web-app-title content="boatrain的博客"><link rel="shortcut icon" type=image/x-icon href=/favicon.ico><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=manifest href=/site.webmanifest><link rel=canonical href=https://boatrainlsz.github.io/posts/go/><link rel=prev href=https://boatrainlsz.github.io/posts/first_post/><link rel=next href=https://boatrainlsz.github.io/posts/jvm_metaspace_improvement/><link rel=stylesheet href=/lib/normalize/normalize.min.css><link rel=stylesheet href=/css/style.min.css><link rel=stylesheet href=/lib/fontawesome-free/all.min.css><link rel=stylesheet href=/lib/animate/animate.min.css><script type=application/ld+json>{"@context":"http://schema.org","@type":"BlogPosting","headline":"基于寄存器调用惯例的Go语言接口调用机制","inLanguage":"zh-CN","mainEntityOfPage":{"@type":"WebPage","@id":"https:\/\/boatrainlsz.github.io\/posts\/go\/"},"genre":"posts","keywords":"go, register","wordcount":2640,"url":"https:\/\/boatrainlsz.github.io\/posts\/go\/","datePublished":"2022-04-02T21:35:40+08:00","dateModified":"2022-04-02T21:35:40+08:00","publisher":{"@type":"Organization","name":"boatrain"},"author":{"@type":"Person","name":"boatrain"},"description":""}</script></head><body header-desktop header-mobile><script type=text/javascript>(window.localStorage&&localStorage.getItem("theme")?localStorage.getItem("theme")==="dark":''==="auto"?window.matchMedia("(prefers-color-scheme: dark)").matches:''==="dark")&&document.body.setAttribute("theme","dark")</script><div id=mask></div><div class=wrapper><header class=desktop id=header-desktop><div class=header-wrapper><div class=header-title><a href=/ title=boatrain的博客>boatrain的博客</a></div><div class=menu><div class=menu-inner><a class=menu-item href=/posts/>文章 </a><a class=menu-item href=/tags/>标签 </a><a class=menu-item href=/categories/>分类 </a><a class=menu-item href=/search/><i class="fas fa-fw fa-search"></i> 搜索 </a><span class="menu-item delimiter"></span><a href=javascript:void(0); class="menu-item theme-switch" title=切换主题>
<i class="fas fa-adjust fa-fw"></i></a></div></div></div></header><header class=mobile id=header-mobile><div class=header-container><div class=header-wrapper><div class=header-title><a href=/ title=boatrain的博客>boatrain的博客</a></div><div class=menu-toggle id=menu-toggle-mobile><span></span><span></span><span></span></div></div><div class=menu id=menu-mobile><a class=menu-item href=/posts/ title>文章</a><a class=menu-item href=/tags/ title>标签</a><a class=menu-item href=/categories/ title>分类</a><a class=menu-item href=/search/ title><i class="fas fa-fw fa-search"></i>搜索</a><a href=javascript:void(0); class="menu-item theme-switch" title=切换主题>
<i class="fas fa-adjust fa-fw"></i></a></div></div></header><div class="search-dropdown desktop"><div id=search-dropdown-desktop></div></div><div class="search-dropdown mobile"><div id=search-dropdown-mobile></div></div><main class=main><div class=container><div class=toc id=toc-auto><h2 class=toc-title>目录</h2><div class=toc-content id=toc-content-auto></div></div><article class="page single"><h1 class="single-title animated flipInX">基于寄存器调用惯例的Go语言接口调用机制</h1><div class=post-meta><div class=post-meta-line><span class=post-author><a href=/ title=Author rel=author class=author><i class="fas fa-user-circle fa-fw"></i>boatrain</a></span></div><div class=post-meta-line><i class="far fa-calendar-alt fa-fw"></i>&nbsp;<time datetime=2022-04-02>2022-04-02</time>&nbsp;<i class="fas fa-pencil-alt fa-fw"></i>&nbsp;约 2640 字&nbsp;
<i class="far fa-clock fa-fw"></i>&nbsp;预计阅读 6 分钟&nbsp;</div></div><div class="details toc" id=toc-static kept><div class="details-summary toc-title"><span>目录</span>
<span><i class="details-icon fas fa-angle-right"></i></span></div><div class="details-content toc-content" id=toc-content-static><nav id=TableOfContents><ul><li><ul><li><a href=#摘要>摘要</a></li><li><a href=#go版本说明>Go版本说明</a></li><li><a href=#样例代码>样例代码</a></li><li><a href=#接口的内存布局>接口的内存布局</a></li><li><a href=#寄存器>寄存器</a></li><li><a href=#汇编代码>汇编代码</a></li></ul></li></ul></nav></div></div><div class=content id=content><p>本文是对<a href=https://eli.thegreenplace.net/2022/interface-method-calls-with-the-go-register-abi/ target=_blank rel="noopener noreffer">此文章</a>的学习与翻译。</p><h3 id=摘要>摘要</h3><p>其实这个机制和Java以及C++的接口调用机制差不多，都是基于<a href=https://lukasatkinson.de/2018/interface-dispatch/ target=_blank rel="noopener noreffer">itable</a>，不过Java由于虚拟机规范中没有对方法调用惯例做出明确的规定，所以对Java而言，方法调用惯例是基于寄存器还是栈，完全取决于JVM的具体实现，可参考<a href=https://stackoverflow.com/questions/41693637/whats-the-calling-convention-for-the-java-code-in-linux-platform target=_blank rel="noopener noreffer">此回答</a>。</p><h3 id=go版本说明>Go版本说明</h3><p>网上的很多博客对于Go语言的方法调用，尤其是接口方法调用的描述已经过时了。因为从<a href=https://go.dev/doc/go1.17 target=_blank rel="noopener noreffer">1.17版本</a>开始，在AMD64架构上的方法调用就变为了<a href=https://go.googlesource.com/go/+/refs/heads/master/src/cmd/compile/abi-internal.md target=_blank rel="noopener noreffer">基于寄存器</a>：</p><blockquote><p>Go 1.17 implements a new way of passing function arguments and results using registers instead of the stack. Benchmarks for a representative set of Go packages and programs show performance improvements of about 5%, and a typical reduction in binary size of about 2%. This is currently enabled for Linux, macOS, and Windows on the 64-bit x86 architecture (the <code>linux/amd64</code>, <code>darwin/amd64</code>, and <code>windows/amd64</code> ports).</p></blockquote><p><a href=https://go.dev/doc/go1.18 target=_blank rel="noopener noreffer">1.18版本</a>更进一步，将基于寄存器的方法调用惯例扩展到了其他平台：</p><blockquote><p>Go 1.17 <a href=https://go.dev/doc/go1.17#compiler target=_blank rel="noopener noreffer">implemented</a> a new way of passing function arguments and results using registers instead of the stack on 64-bit x86 architecture on selected operating systems. Go 1.18 expands the supported platforms to include 64-bit ARM (<code>GOARCH=arm64</code>), big- and little-endian 64-bit PowerPC (<code>GOARCH=ppc64</code>, <code>ppc64le</code>), as well as 64-bit x86 architecture (<code>GOARCH=amd64</code>) on all operating systems. On 64-bit ARM and 64-bit PowerPC systems, benchmarking shows typical performance improvements of 10% or more.</p></blockquote><p>本篇文章基于最新的Go 1.18，架构为AMD64。</p><h3 id=样例代码>样例代码</h3><p>本篇文章用<a href=https://www.wikiwand.com/en/Bubble_sort target=_blank rel="noopener noreffer">冒泡排序算法</a>中的内层循环来讲解：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=nf>bubbleUp</span><span class=p>(</span><span class=nx>x</span> <span class=nx>sort</span><span class=p>.</span><span class=nx>Interface</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=nx>n</span> <span class=o>:=</span> <span class=nx>x</span><span class=p>.</span><span class=nf>Len</span><span class=p>()</span>
</span></span><span class=line><span class=cl>  <span class=k>for</span> <span class=nx>i</span> <span class=o>:=</span> <span class=mi>1</span><span class=p>;</span> <span class=nx>i</span> <span class=p>&lt;</span> <span class=nx>n</span><span class=p>;</span> <span class=nx>i</span><span class=o>++</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=nx>x</span><span class=p>.</span><span class=nf>Less</span><span class=p>(</span><span class=nx>i</span><span class=p>,</span> <span class=nx>i</span><span class=o>-</span><span class=mi>1</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=nx>x</span><span class=p>.</span><span class=nf>Swap</span><span class=p>(</span><span class=nx>i</span><span class=p>,</span> <span class=nx>i</span><span class=o>-</span><span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>这里的sort.Interface是Go标准库里的接口，其定义如下：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>type</span> <span class=nx>Interface</span> <span class=kd>interface</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=nf>Len</span><span class=p>()</span> <span class=kt>int</span>
</span></span><span class=line><span class=cl>  <span class=nf>Less</span><span class=p>(</span><span class=nx>i</span><span class=p>,</span> <span class=nx>j</span> <span class=kt>int</span><span class=p>)</span> <span class=kt>bool</span>
</span></span><span class=line><span class=cl>  <span class=nf>Swap</span><span class=p>(</span><span class=nx>i</span><span class=p>,</span> <span class=nx>j</span> <span class=kt>int</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>只要实现了sort.Interface接口，就可以当作bubbleUp函数的参数x，但最常用的还是slice。</p><h3 id=接口的内存布局>接口的内存布局</h3><p>接口在Go runtime中的内部表示如下：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>type</span> <span class=nx>iface</span> <span class=kd>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=nx>tab</span>  <span class=o>*</span><span class=nx>itab</span>
</span></span><span class=line><span class=cl>  <span class=nx>data</span> <span class=nx>unsafe</span><span class=p>.</span><span class=nx>Pointer</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>在64位机器上，tab和data都是64bit，共128bit，也就是两个4字，其中itab类型定义如下：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>type</span> <span class=nx>itab</span> <span class=kd>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=nx>inter</span> <span class=o>*</span><span class=nx>interfacetype</span>
</span></span><span class=line><span class=cl>  <span class=nx>_type</span> <span class=o>*</span><span class=nx>_type</span>
</span></span><span class=line><span class=cl>  <span class=nx>hash</span>  <span class=kt>uint32</span> <span class=c1>// copy of _type.hash. Used for type switches.
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=nx>_</span>     <span class=p>[</span><span class=mi>4</span><span class=p>]</span><span class=kt>byte</span>
</span></span><span class=line><span class=cl>  <span class=nx>fun</span>   <span class=p>[</span><span class=mi>1</span><span class=p>]</span><span class=kt>uintptr</span> <span class=c1>// variable sized. fun[0]==0 means _type does not implement inter.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span></code></pre></div><p>这里重点关注<code>fun</code>字段，它是一个可变大小的函数指针数组，这就是分派表</p><h3 id=寄存器>寄存器</h3><p>目前在AMD64架构上，Go依次使用以下寄存器用作函数调用：</p><blockquote><p>RAX, RBX, RCX, RDI, RSI, R8, R9, R10, R11</p></blockquote><p>有时候，一个参数会占用多个寄存器，比如上面说的iface接口，它占用64*2=128bit，那么如果接口值被当作第一个参数传给函数，则其tab字段和data字段将分别占据RAX和RBX寄存器，如果接口值被当作第二个参数传给函数，此时，第一个参数已经占据了RAX，则其tab字段和data字段将分别占据RBX和RCX寄存器，以此类推。顺便提一下，Go语言使用的Plan9汇编语言不使用前缀R来访问这些寄存器(RAX, RBX, RCX, RDI, RSI)，而是直接用AX，BX等名字。</p><h3 id=汇编代码>汇编代码</h3><p>使用如下命令将样例代码反汇编：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>go tool compile -S bubble.go
</span></span></code></pre></div><blockquote><p>关于Go语言的汇编入门，可以参考<a href=https://xargin.com/plan9-assembly/ target=_blank rel="noopener noreffer">这篇文章</a></p></blockquote><p>得到的完整汇编代码见<a href=https://gist.github.com/boatrainlsz/d36c1d24e3a55ad752eb96ec5b6789c0 target=_blank rel="noopener noreffer">gist</a>。</p><p>略去下面这段<a href=https://www.wikiwand.com/en/Function_prologue_and_epilogue target=_blank rel="noopener noreffer">函数序言</a>：</p><pre tabindex=0><code class=language-assembly data-lang=assembly>&#34;&#34;.bubbleUp STEXT size=182 args=0x10 locals=0x38 funcid=0x0 align=0x0
        0x0000 00000 (bubble.go:3)      TEXT    &#34;&#34;.bubbleUp(SB), ABIInternal, $56-16
        0x0000 00000 (bubble.go:3)      CMPQ    SP, 16(R14)
        0x0004 00004 (bubble.go:3)      PCDATA  $0, $-2
        0x0004 00004 (bubble.go:3)      JLS     152
        0x000a 00010 (bubble.go:3)      PCDATA  $0, $-1
        0x000a 00010 (bubble.go:3)      SUBQ    $56, SP
        0x000e 00014 (bubble.go:3)      MOVQ    BP, 48(SP)
        0x0013 00019 (bubble.go:3)      LEAQ    48(SP), BP
</code></pre><p>略去下面这段GC相关代码：</p><pre tabindex=0><code class=language-assembly data-lang=assembly>0x0018 00024 (bubble.go:3)      FUNCDATA        $0, gclocals·09cf9819fc716118c209c2d2155a3632(SB)
0x0018 00024 (bubble.go:3)      FUNCDATA        $1, gclocals·69c1753bd5f81501d95132d08af04464(SB)
0x0018 00024 (bubble.go:3)      FUNCDATA        $5, &#34;&#34;.bubbleUp.arginfo1(SB)
0x0018 00024 (bubble.go:3)      FUNCDATA        $6, &#34;&#34;.bubbleUp.argliveinfo(SB)
</code></pre><p>重点来分析函数主体代码：</p><pre tabindex=0><code class=language-assembly data-lang=assembly>0x0018 00024 (bubble.go:4)      MOVQ    AX, &#34;&#34;.x+64(SP)
0x001d 00029 (bubble.go:4)      MOVQ    BX, &#34;&#34;.x+72(SP)
0x0022 00034 (bubble.go:4)      MOVQ    24(AX), CX
0x0026 00038 (bubble.go:4)      MOVQ    BX, AX
0x0029 00041 (bubble.go:4)      CALL    CX
</code></pre><h4 id=参数暂存>参数暂存</h4><p>函数开始，如上文所述，接口值将占据<code>AX</code>，<code>BX</code>寄存器：其中AX为<code>MOVQ AX, "".x+64(SP)</code>和<code>MOVQ BX, "".x+72(SP)</code>将接口值复制到栈上(SP：Stack Pointer)，以便为后续<code>AX</code>，<code>BX</code>寄存器的使用腾出空间。</p><h4 id=找到函数调用地址>找到函数调用地址</h4><p>接下来，准备调用<code>x.Len()</code>，此时，就需要找到要调用的函数，而这个函数的入口地址就存放在<code>24(AX)</code>，其原理是这样的：</p><ul><li>如前所述，传递给函数bubbleUp的参数<code>x</code>，其值存放在<code>AX</code>，<code>BX</code>寄存器。</li><li>根据<code>iface</code>的内存布局，<code>AX</code>寄存器存放的正是指向itab的指针</li><li><code>24(AX)</code>意思是<code>AX+24</code>，这里24是十进制，表示指针地址+偏移量24bytes</li><li><code>itab</code>中24bytes偏移量正是指向<code>itab</code>中的<code>fun</code>字段，也就是接口中的第一个函数的地址被放置在寄存器<code>CX</code>中</li><li>而<code>sort.Interface</code>接口的第一个方法正是<code>Len()</code>方法，所以最后，<code>x</code>的<code>Len()</code>方法的地址就存放在<code>CX</code>寄存器中了</li></ul><h4 id=调用函数>调用函数</h4><p>函数地址找到了，接下来就是调用函数了。因为<code>Len()</code>方法没有参数，所以唯一一个需要传递的参数就是函数的接收者(receiver)，注意到在之前的操作中已经把接口的<code>tab</code>字段和<code>data</code>字段将分别存放到了<code>AX</code>和<code>BX</code>寄存器，<code>data</code>字段正是存放了实际的接口值，也就是函数的接收者，所以接下来使用<code>MOVQ BX, AX</code>将函数的接收者放在<code>AX</code>寄存器中，然后用<code>CALL CX</code>调用函数。</p><h4 id=函数返回值>函数返回值</h4><p><code>Len()</code>方法返回一个整数<code>n</code>，存放在<code>AX</code>寄存器中，这里将返回值存放到了栈上，因为接下来<code>AX</code>寄存器将用作其他用途：</p><pre tabindex=0><code class=language-assembly data-lang=assembly>0x002b 00043 (bubble.go:4)      MOVQ    AX, &#34;&#34;.n+24(SP)
</code></pre><h4 id=开始循环>开始循环</h4><p>接下来的代码就是for循环的汇编实现：</p><pre tabindex=0><code class=language-assembly data-lang=assembly>0x0030 00048 (bubble.go:4)      MOVL    $1, CX
0x0035 00053 (bubble.go:5)      JMP     69                  ---&gt;\
0x0037 00055 (bubble.go:5)      MOVQ    &#34;&#34;.i+32(SP), DX         |
0x003c 00060 (bubble.go:5)      LEAQ    1(DX), CX               |i++
0x0040 00064 (bubble.go:5)      MOVQ    &#34;&#34;.n+24(SP), AX         |
0x0045 00069 (bubble.go:5)      CMPQ    AX, CX              &lt;---/
0x0048 00072 (bubble.go:5)      JLE     142
0x004a 00074 (bubble.go:5)      MOVQ    CX, &#34;&#34;.i+32(SP)
0x004f 00079 (bubble.go:6)      MOVQ    &#34;&#34;.x+64(SP), DX
0x0054 00084 (bubble.go:6)      MOVQ    32(DX), SI
0x0058 00088 (bubble.go:6)      LEAQ    -1(CX), DI
0x005c 00092 (bubble.go:6)      MOVQ    DI, &#34;&#34;..autotmp_4+40(SP)
0x0061 00097 (bubble.go:6)      MOVQ    &#34;&#34;.x+72(SP), AX
0x0066 00102 (bubble.go:6)      MOVQ    CX, BX
0x0069 00105 (bubble.go:6)      MOVQ    DI, CX
0x006c 00108 (bubble.go:6)      CALL    SI
0x006e 00110 (bubble.go:6)      TESTB   AL, AL
0x0070 00112 (bubble.go:6)      JEQ     55
0x0072 00114 (bubble.go:7)      MOVQ    &#34;&#34;.x+64(SP), DX
0x0077 00119 (bubble.go:7)      MOVQ    40(DX), SI
0x007b 00123 (bubble.go:7)      MOVQ    &#34;&#34;.x+72(SP), AX
0x0080 00128 (bubble.go:7)      MOVQ    &#34;&#34;.i+32(SP), BX
0x0085 00133 (bubble.go:7)      MOVQ    &#34;&#34;..autotmp_4+40(SP), CX
0x008a 00138 (bubble.go:7)      CALL    SI
0x008c 00140 (bubble.go:7)      JMP     55
0x008e 00142 (bubble.go:10)     PCDATA  $1, $-1
0x008e 00142 (bubble.go:10)     MOVQ    48(SP), BP
</code></pre><p><code>i++</code>的实现：首先将<code>CX</code>寄存器赋初始值1，然后跳转到第69行<code>CMPQ AX, CX</code>(注意此时<code>AX</code>中的值为<code>n</code>)，也就是比较<code>n</code>和<code>i</code>的大小，并且当<code>i>=n</code>时将跳出循环(<code>JLE 142</code>)。第55行至64行就是<code>i++</code>的实现。</p><p>调用<code>x.Less()</code>方法：回想一下，<code>itab</code>中的第一个方法<code>Len()</code>方法的偏移量为24bytes，所以第二个方法，<code>Less()</code>方法的偏移量是32bytes。这里首先将存放于栈上的<code>iface</code>值复制到<code>DX</code>寄存器中，然后再将<code>Less()</code>方法的地址放入<code>SI</code>寄存器，到第105行为止，都是在进行调用<code>x.Less()</code>方法的准备工作。执行到第105行时，此时：</p><ul><li><code>Less()</code>方法的接收者<code>x</code>在<code>AX</code>寄存器中</li><li><code>i</code>在<code>BX</code>寄存器中</li><li><code>i</code>-1在<code>CX</code>寄存器中</li></ul><p><code>Less()</code>方法返回值存放在<code>AL</code>寄存器中，0代表false，1代表true，这两行代码判断<code>Less()</code>方法返回值，若为false，则直接跳到55行，继续下个循环，否则继续执行<code>Swap()</code>方法：</p><pre tabindex=0><code>0x0072 00114 (bubble.go:7)      MOVQ    &#34;&#34;.x+64(SP), DX
0x0077 00119 (bubble.go:7)      MOVQ    40(DX), SI
0x007b 00123 (bubble.go:7)      MOVQ    &#34;&#34;.x+72(SP), AX
0x0080 00128 (bubble.go:7)      MOVQ    &#34;&#34;.i+32(SP), BX
0x0085 00133 (bubble.go:7)      MOVQ    &#34;&#34;..autotmp_4+40(SP), CX
0x008a 00138 (bubble.go:7)      CALL    SI
</code></pre><p>紧跟着就是for循环的回边语句：</p><pre tabindex=0><code class=language-assembly data-lang=assembly>0x008c 00140 (bubble.go:15)  JMP  55
</code></pre><p>最后就是函数的尾言和返回语句：</p><pre tabindex=0><code class=language-assembly data-lang=assembly>0x0093 00147 (bubble.go:10)     ADDQ    $56, SP
0x0097 00151 (bubble.go:10)     RET
0x0098 00152 (bubble.go:10)     N
</code></pre></div><div class=post-footer id=post-footer><div class=post-info><div class=post-info-line><div class=post-info-mod><span>更新于 2022-04-02</span></div><div class=post-info-license></div></div><div class=post-info-line><div class=post-info-md></div><div class=post-info-share><span></span></div></div></div><div class=post-info-more><section class=post-tags><i class="fas fa-tags fa-fw"></i>&nbsp;<a href=/tags/go/>go</a>,&nbsp;<a href=/tags/register/>register</a></section><section><span><a href=javascript:void(0); onclick=window.history.back()>返回</a></span>&nbsp;|&nbsp;<span><a href=/>主页</a></span></section></div><div class=post-nav><a href=/posts/first_post/ class=prev rel=prev title=go的并发编程><i class="fas fa-angle-left fa-fw"></i>go的并发编程</a>
<a href=/posts/jvm_metaspace_improvement/ class=next rel=next title=JDK元空间的内存分配体系>JDK元空间的内存分配体系<i class="fas fa-angle-right fa-fw"></i></a></div></div><div id=comments><div id=utterances></div><noscript>Please enable JavaScript to view the comments powered by <a href=https://utteranc.es/>Utterances</a>.</noscript></div></article></div></main><footer class=footer><div class=footer-container><div class=footer-line>由 <a href=https://gohugo.io/ target=_blank rel="noopener noreffer" title="Hugo 0.97.3">Hugo</a> 强力驱动 | 主题 - <a href=https://github.com/dillonzq/LoveIt target=_blank rel="noopener noreffer" title="LoveIt 0.2.10"><i class="far fa-kiss-wink-heart fa-fw"></i> LoveIt</a></div><div class=footer-line><i class="far fa-copyright fa-fw"></i><span itemprop=copyrightYear>2022</span><span class=author itemprop=copyrightHolder>&nbsp;<a href=/ target=_blank>boatrain</a></span></div></div></footer></div><div id=fixed-buttons><a href=# id=back-to-top class=fixed-button title=回到顶部><i class="fas fa-arrow-up fa-fw"></i>
</a><a href=# id=view-comments class=fixed-button title=查看评论><i class="fas fa-comment fa-fw"></i></a></div><link rel=stylesheet href=/lib/lightgallery/lightgallery.min.css><link rel=stylesheet href=/lib/katex/katex.min.css><script type=text/javascript src=/lib/smooth-scroll/smooth-scroll.min.js></script><script type=text/javascript src=/lib/lazysizes/lazysizes.min.js></script><script type=text/javascript src=/lib/lightgallery/lightgallery.min.js></script><script type=text/javascript src=/lib/lightgallery/lg-thumbnail.min.js></script><script type=text/javascript src=/lib/lightgallery/lg-zoom.min.js></script><script type=text/javascript src=/lib/clipboard/clipboard.min.js></script><script type=text/javascript src=/lib/katex/katex.min.js></script><script type=text/javascript src=/lib/katex/auto-render.min.js></script><script type=text/javascript>window.config={code:{copyTitle:"复制到剪贴板",maxShownLines:10},comment:{utterances:{darkTheme:"github-dark",issueTerm:"pathname",label:"Comment",lightTheme:"github-light",repo:"boatrainlsz/blog-comment"}},lightGallery:{actualSize:!1,exThumbImage:"data-thumbnail",hideBarsDelay:2e3,selector:".lightgallery",speed:400,thumbContHeight:80,thumbWidth:80,thumbnail:!0},math:{delimiters:[{display:!0,left:"$$",right:"$$"},{display:!0,left:"\\[",right:"\\]"},{display:!1,left:"$",right:"$"},{display:!1,left:"\\(",right:"\\)"}],strict:!1}}</script><script type=text/javascript src=/js/theme.min.js></script><script type=text/javascript>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-SLGEHM7PTD")</script><script type=text/javascript src="https://www.googletagmanager.com/gtag/js?id=G-SLGEHM7PTD" async></script></body></html>