<!doctype html><html lang=zh-CN><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=robots content="noodp"><meta http-equiv=X-UA-Compatible content="IE=edge, chrome=1"><title>《数据密集型应用系统设计》第3章-数据存储与检索 - boatrain的博客</title><meta name=Description content="《数据密集型应用系统设计》第3章-数据存储与检索"><meta property="og:title" content="《数据密集型应用系统设计》第3章-数据存储与检索">
<meta property="og:description" content="《数据密集型应用系统设计》第3章-数据存储与检索"><meta property="og:type" content="article"><meta property="og:url" content="https://boatrainlsz.github.io/posts/ddia/ch03-storage-and-retrieval/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-10-21T21:31:19+08:00"><meta property="article:modified_time" content="2023-10-21T21:31:19+08:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="《数据密集型应用系统设计》第3章-数据存储与检索"><meta name=twitter:description content="《数据密集型应用系统设计》第3章-数据存储与检索"><meta name=twitter:site content="@boatrain666"><meta name=application-name content="boatrain的博客"><meta name=apple-mobile-web-app-title content="boatrain的博客"><link rel="shortcut icon" type=image/x-icon href=/favicon.ico><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=manifest href=/site.webmanifest><link rel=canonical href=https://boatrainlsz.github.io/posts/ddia/ch03-storage-and-retrieval/><link rel=prev href=https://boatrainlsz.github.io/posts/ddia/ch09-consistency-and-concensus/><link rel=next href=https://boatrainlsz.github.io/posts/ddia/ch06-partitioning/><link rel=stylesheet href=/lib/normalize/normalize.min.css><link rel=stylesheet href=/css/style.min.css><link rel=stylesheet href=/lib/fontawesome-free/all.min.css><link rel=stylesheet href=/lib/animate/animate.min.css><script type=application/ld+json>{"@context":"http://schema.org","@type":"BlogPosting","headline":"《数据密集型应用系统设计》第3章-数据存储与检索","inLanguage":"zh-CN","mainEntityOfPage":{"@type":"WebPage","@id":"https:\/\/boatrainlsz.github.io\/posts\/ddia\/ch03-storage-and-retrieval\/"},"genre":"posts","keywords":"数据密集型应用系统设计, 读书笔记","wordcount":1773,"url":"https:\/\/boatrainlsz.github.io\/posts\/ddia\/ch03-storage-and-retrieval\/","datePublished":"2023-10-21T21:31:19+08:00","dateModified":"2023-10-21T21:31:19+08:00","publisher":{"@type":"Organization","name":"boatrain"},"author":{"@type":"Person","name":"boatrain"},"description":"《数据密集型应用系统设计》第3章-数据存储与检索"}</script></head><body header-desktop header-mobile><script type=text/javascript>(window.localStorage&&localStorage.getItem("theme")?localStorage.getItem("theme")==="dark":""==="auto"?window.matchMedia("(prefers-color-scheme: dark)").matches:""==="dark")&&document.body.setAttribute("theme","dark")</script><div id=mask></div><div class=wrapper><header class=desktop id=header-desktop><div class=header-wrapper><div class=header-title><a href=/ title=boatrain的博客>boatrain的博客</a></div><div class=menu><div class=menu-inner><a class=menu-item href=/posts/>文章 </a><a class=menu-item href=/tags/>标签 </a><a class=menu-item href=/categories/>分类 </a><a class=menu-item href=/search/><i class='fas fa-fw fa-search'></i> 搜索 </a><span class="menu-item delimiter"></span><a href=javascript:void(0); class="menu-item theme-switch" title=切换主题>
<i class="fas fa-adjust fa-fw"></i></a></div></div></div></header><header class=mobile id=header-mobile><div class=header-container><div class=header-wrapper><div class=header-title><a href=/ title=boatrain的博客>boatrain的博客</a></div><div class=menu-toggle id=menu-toggle-mobile><span></span><span></span><span></span></div></div><div class=menu id=menu-mobile><a class=menu-item href=/posts/ title>文章</a><a class=menu-item href=/tags/ title>标签</a><a class=menu-item href=/categories/ title>分类</a><a class=menu-item href=/search/ title><i class='fas fa-fw fa-search'></i>搜索</a><a href=javascript:void(0); class="menu-item theme-switch" title=切换主题>
<i class="fas fa-adjust fa-fw"></i></a></div></div></header><div class="search-dropdown desktop"><div id=search-dropdown-desktop></div></div><div class="search-dropdown mobile"><div id=search-dropdown-mobile></div></div><main class=main><div class=container><div class=toc id=toc-auto><h2 class=toc-title>目录</h2><div class=toc-content id=toc-content-auto></div></div><article class="page single"><h1 class="single-title animated flipInX">《数据密集型应用系统设计》第3章-数据存储与检索</h1><div class=post-meta><div class=post-meta-line><span class=post-author><a href=/ title=Author rel=author class=author><i class="fas fa-user-circle fa-fw"></i>boatrain</a></span></div><div class=post-meta-line><i class="far fa-calendar-alt fa-fw"></i>&nbsp;<time datetime=2023-10-21>2023-10-21</time>&nbsp;<i class="fas fa-pencil-alt fa-fw"></i>&nbsp;约 1773 字&nbsp;
<i class="far fa-clock fa-fw"></i>&nbsp;预计阅读 4 分钟&nbsp;</div></div><div class="details toc" id=toc-static kept><div class="details-summary toc-title"><span>目录</span>
<span><i class="details-icon fas fa-angle-right"></i></span></div><div class="details-content toc-content" id=toc-content-static><nav id=TableOfContents><ul><li><ul><li><a href=#oltp和olap>OLTP和OLAP</a></li><li><a href=#oltp的存储格式>OLTP的存储格式</a></li><li><a href=#olap的存储格式>OLAP的存储格式</a></li></ul></li></ul></nav></div></div><div class=content id=content><h3 id=oltp和olap>OLTP和OLAP</h3><p>二者区别如下：</p><p><img class=lazyload src=/svg/loading.min.svg data-src=https://raw.githubusercontent.com/boatrainlsz/my-image-hosting/main/Screenshot_select-area_20231021213804.png data-srcset="https://raw.githubusercontent.com/boatrainlsz/my-image-hosting/main/Screenshot_select-area_20231021213804.png, https://raw.githubusercontent.com/boatrainlsz/my-image-hosting/main/Screenshot_select-area_20231021213804.png 1.5x, https://raw.githubusercontent.com/boatrainlsz/my-image-hosting/main/Screenshot_select-area_20231021213804.png 2x" data-sizes=auto alt=https://raw.githubusercontent.com/boatrainlsz/my-image-hosting/main/Screenshot_select-area_20231021213804.png title=https://raw.githubusercontent.com/boatrainlsz/my-image-hosting/main/Screenshot_select-area_20231021213804.png></p><p>正是这些区别，导致了它们存储格式的不同。</p><h3 id=oltp的存储格式>OLTP的存储格式</h3><h4 id=从最简单的说起>从最简单的说起</h4><h5 id=一个基本的索引--磁盘存储>一个基本的索引 + 磁盘存储</h5><p><img class=lazyload src=/svg/loading.min.svg data-src=https://raw.githubusercontent.com/boatrainlsz/my-image-hosting/main/Screenshot_select-area_20231021214413.png data-srcset="https://raw.githubusercontent.com/boatrainlsz/my-image-hosting/main/Screenshot_select-area_20231021214413.png, https://raw.githubusercontent.com/boatrainlsz/my-image-hosting/main/Screenshot_select-area_20231021214413.png 1.5x, https://raw.githubusercontent.com/boatrainlsz/my-image-hosting/main/Screenshot_select-area_20231021214413.png 2x" data-sizes=auto alt=https://raw.githubusercontent.com/boatrainlsz/my-image-hosting/main/Screenshot_select-area_20231021214413.png title=https://raw.githubusercontent.com/boatrainlsz/my-image-hosting/main/Screenshot_select-area_20231021214413.png></p><h5 id=优化存储占用---压缩>优化存储占用 - 压缩</h5><p>丢弃重复的key，每个key只保留最新的值：</p><p><img class=lazyload src=/svg/loading.min.svg data-src=https://raw.githubusercontent.com/boatrainlsz/my-image-hosting/main/Screenshot_select-area_20231021214622.png data-srcset="https://raw.githubusercontent.com/boatrainlsz/my-image-hosting/main/Screenshot_select-area_20231021214622.png, https://raw.githubusercontent.com/boatrainlsz/my-image-hosting/main/Screenshot_select-area_20231021214622.png 1.5x, https://raw.githubusercontent.com/boatrainlsz/my-image-hosting/main/Screenshot_select-area_20231021214622.png 2x" data-sizes=auto alt=https://raw.githubusercontent.com/boatrainlsz/my-image-hosting/main/Screenshot_select-area_20231021214622.png title=https://raw.githubusercontent.com/boatrainlsz/my-image-hosting/main/Screenshot_select-area_20231021214622.png></p><p>但是上面这种结构有以下缺点：</p><ol><li>哈希索引必须全部放入内存，因为磁盘上的哈希索引需要大量的随机IO。</li><li>区间查询效率不高，只能逐个查询。</li></ol><p>这些问题将由下面的存储结构解决。</p><h4 id=sstables和lsm-tree>SSTables和LSM-Tree</h4><h5 id=sstables>SSTables</h5><p>排序字符串表，每个key在每个合并的段文件中只能出现一次。它的段文件合并过程与内存索引如下：</p><p><img class=lazyload src=/svg/loading.min.svg data-src=https://raw.githubusercontent.com/boatrainlsz/my-image-hosting/main/Screenshot_select-area_20231021215221.png data-srcset="https://raw.githubusercontent.com/boatrainlsz/my-image-hosting/main/Screenshot_select-area_20231021215221.png, https://raw.githubusercontent.com/boatrainlsz/my-image-hosting/main/Screenshot_select-area_20231021215221.png 1.5x, https://raw.githubusercontent.com/boatrainlsz/my-image-hosting/main/Screenshot_select-area_20231021215221.png 2x" data-sizes=auto alt=https://raw.githubusercontent.com/boatrainlsz/my-image-hosting/main/Screenshot_select-area_20231021215221.png title=https://raw.githubusercontent.com/boatrainlsz/my-image-hosting/main/Screenshot_select-area_20231021215221.png></p><p><img class=lazyload src=/svg/loading.min.svg data-src=https://raw.githubusercontent.com/boatrainlsz/my-image-hosting/main/Screenshot_select-area_20231021215250.png data-srcset="https://raw.githubusercontent.com/boatrainlsz/my-image-hosting/main/Screenshot_select-area_20231021215250.png, https://raw.githubusercontent.com/boatrainlsz/my-image-hosting/main/Screenshot_select-area_20231021215250.png 1.5x, https://raw.githubusercontent.com/boatrainlsz/my-image-hosting/main/Screenshot_select-area_20231021215250.png 2x" data-sizes=auto alt=https://raw.githubusercontent.com/boatrainlsz/my-image-hosting/main/Screenshot_select-area_20231021215250.png title=https://raw.githubusercontent.com/boatrainlsz/my-image-hosting/main/Screenshot_select-area_20231021215250.png></p><h5 id=lsm-tree的引入>LSM-Tree的引入</h5><p>SSTables的读取已在上面讲过，那写入呢，写入可能以任意顺序出现，该如何让数据排序呢？一般流程如下：</p><ol><li>先写入内存中的平衡树结构中，比如红黑树或者AVL树，此结构被称为内存表。</li><li>内存表达到某个阈值时，将其作为SSTables文件写入磁盘，阈值一般为几兆。因为内存表是有序的，所以写入磁盘很高效。</li><li>读请求，先读内存表，找不到，就再读最新的磁盘段文件，然后再读次新的段文件，以此类推。</li><li>后台进程周期性执行合并与压缩。</li><li>为了防止崩溃丢失数据，还会引入一个日志文件，以记录每个写入。</li></ol><p>上面这个思路被称为Log-Structured Merge-Tree，即LSM-Tree。LevelDB、RocksDB、Cassandra、HBase等都采用了类似的技术。</p><h5 id=lsm-tree的优化>LSM-Tree的优化</h5><p>查找一个不存在的key会很慢，看上面的第3点。所以引入<a href="https://en.wikipedia.org/wiki/Bloom_filter?useskin=vector" target=_blank rel="noopener noreffer">布隆过滤器</a>，当key不存在时，能很快得出结果。</p><h4 id=b-tree>B-Tree</h4><p>B-Tree将数据库分解为固定大小的页，一般为4K，和底层磁盘的页大小相适配。一个页面由以下数据组成：</p><ol><li>若干个key，key是连续的</li><li>对子页的引用</li></ol><p><img class=lazyload src=/svg/loading.min.svg data-src=https://raw.githubusercontent.com/boatrainlsz/my-image-hosting/main/Screenshot_select-area_20231021221205.png data-srcset="https://raw.githubusercontent.com/boatrainlsz/my-image-hosting/main/Screenshot_select-area_20231021221205.png, https://raw.githubusercontent.com/boatrainlsz/my-image-hosting/main/Screenshot_select-area_20231021221205.png 1.5x, https://raw.githubusercontent.com/boatrainlsz/my-image-hosting/main/Screenshot_select-area_20231021221205.png 2x" data-sizes=auto alt=https://raw.githubusercontent.com/boatrainlsz/my-image-hosting/main/Screenshot_select-area_20231021221205.png title=https://raw.githubusercontent.com/boatrainlsz/my-image-hosting/main/Screenshot_select-area_20231021221205.png></p><p>一个页所引用的子页个数称为分支因子, $ n $个key的B-Tree深度为 $O(log n)$。4层、分支因子为500、页大小为4K的B-Tree就可以存储256TB的数据。</p><h5 id=b-tree的增删改查>B-Tree的增删改查</h5><p>上面已经说过查询了，改数据也比较容易，先查到页，更改，再写入。增加新key，也是先查到页，添加key，如果页容量不够的话，则可能涉及到页的分裂：</p><p><img class=lazyload src=/svg/loading.min.svg data-src=https://raw.githubusercontent.com/boatrainlsz/my-image-hosting/main/Screenshot_select-area_20231021222205.png data-srcset="https://raw.githubusercontent.com/boatrainlsz/my-image-hosting/main/Screenshot_select-area_20231021222205.png, https://raw.githubusercontent.com/boatrainlsz/my-image-hosting/main/Screenshot_select-area_20231021222205.png 1.5x, https://raw.githubusercontent.com/boatrainlsz/my-image-hosting/main/Screenshot_select-area_20231021222205.png 2x" data-sizes=auto alt=https://raw.githubusercontent.com/boatrainlsz/my-image-hosting/main/Screenshot_select-area_20231021222205.png title=https://raw.githubusercontent.com/boatrainlsz/my-image-hosting/main/Screenshot_select-area_20231021222205.png></p><p>删除则更复杂了，详见《算法导论》的18.3节。同样地，为了防止崩溃导致数据丢失，会引入一个日志文件，以记录每个写入，称为write-ahead log（WAL），也被称为预写日志、重做日志。</p><h5 id=b-tree的几种优化>B-Tree的几种优化</h5><ol><li>写时复制，COW。</li><li>B+Tree，叶子节点存储数据，其他的节点只存key，以节省页空间，增加分支因子，减少层数。叶子节点增加对左右兄弟的引用，这样范围查询时就不用再跳回父页了。</li></ol><h4 id=b-tree和lsm-tree对比>B-Tree和LSM-Tree对比</h4><p>写放大：一次数据库写入导致多次磁盘写。</p><ol><li>LSM-Tree的写放大比B-Tree要来的小，因为LSM-Tree顺序写入紧凑的SSTable文件。</li><li>B-Tree必须至少写两次，一次写入预写日志，一次写入树的页本身。MySQL InnoDB甚至存在Double Write，即同一页写两次。</li><li>LSM-Tree对压缩支持更好，存储开销更小。</li><li>虽然LSM-Tree对压缩支持更好，但带来的副作用是：高吞吐量写入时，磁盘带宽被压缩和写入共享。</li><li>B-Tree提供强大的事务语义，事务隔离通常以在key范围内加锁来实现。</li></ol><h3 id=olap的存储格式>OLAP的存储格式</h3><p>数据仓库：使用单独的数据库（数据仓库）进行分析，而不是在OLTP系统上。</p><p>ETL：Extract-Transform-Load，即将数据导入数据仓库的过程。</p><h4 id=星型分析模式>星型分析模式</h4><p>事实表在中间，通过外键与维度表关联，仿佛星星一样，因而得名。</p><p><img class=lazyload src=/svg/loading.min.svg data-src=https://raw.githubusercontent.com/boatrainlsz/my-image-hosting/main/Screenshot_select-area_20231022112045.png data-srcset="https://raw.githubusercontent.com/boatrainlsz/my-image-hosting/main/Screenshot_select-area_20231022112045.png, https://raw.githubusercontent.com/boatrainlsz/my-image-hosting/main/Screenshot_select-area_20231022112045.png 1.5x, https://raw.githubusercontent.com/boatrainlsz/my-image-hosting/main/Screenshot_select-area_20231022112045.png 2x" data-sizes=auto alt=https://raw.githubusercontent.com/boatrainlsz/my-image-hosting/main/Screenshot_select-area_20231022112045.png title=https://raw.githubusercontent.com/boatrainlsz/my-image-hosting/main/Screenshot_select-area_20231022112045.png></p><h4 id=雪花型分析模式>雪花型分析模式</h4><p>雪花型分析是在星型分析基础上更进一步，即维度表还可以再关联子维度表，这样形成一个雪花图案。</p><h4 id=列式存储>列式存储</h4><h5 id=引入的目的>引入的目的</h5><p>行存储不利于OLAP，事实表一般有几百列，而分析往往只需要几列。如果采用行存储，仍需将所有行查出来，然后过滤。而列存储可以高效地支持此种查询：</p><p><img class=lazyload src=/svg/loading.min.svg data-src=https://raw.githubusercontent.com/boatrainlsz/my-image-hosting/main/Screenshot_select-area_20231022112701.png data-srcset="https://raw.githubusercontent.com/boatrainlsz/my-image-hosting/main/Screenshot_select-area_20231022112701.png, https://raw.githubusercontent.com/boatrainlsz/my-image-hosting/main/Screenshot_select-area_20231022112701.png 1.5x, https://raw.githubusercontent.com/boatrainlsz/my-image-hosting/main/Screenshot_select-area_20231022112701.png 2x" data-sizes=auto alt=https://raw.githubusercontent.com/boatrainlsz/my-image-hosting/main/Screenshot_select-area_20231022112701.png title=https://raw.githubusercontent.com/boatrainlsz/my-image-hosting/main/Screenshot_select-area_20231022112701.png></p><p>每个列文件以相同的顺序保存数据行，读哪一列，直接读取文件即可。而且可以很方便的以相同的偏移量读取行。</p><h5 id=列压缩>列压缩</h5><p>引入bitmap进行压缩：</p><p><img class=lazyload src=/svg/loading.min.svg data-src=https://raw.githubusercontent.com/boatrainlsz/my-image-hosting/main/Screenshot_select-area_20231022113150.png data-srcset="https://raw.githubusercontent.com/boatrainlsz/my-image-hosting/main/Screenshot_select-area_20231022113150.png, https://raw.githubusercontent.com/boatrainlsz/my-image-hosting/main/Screenshot_select-area_20231022113150.png 1.5x, https://raw.githubusercontent.com/boatrainlsz/my-image-hosting/main/Screenshot_select-area_20231022113150.png 2x" data-sizes=auto alt=https://raw.githubusercontent.com/boatrainlsz/my-image-hosting/main/Screenshot_select-area_20231022113150.png title=https://raw.githubusercontent.com/boatrainlsz/my-image-hosting/main/Screenshot_select-area_20231022113150.png></p><h5 id=物化视图>物化视图</h5><p>实际查询结果的副本，并被写入磁盘。当底层数据发生变化时，物化视图也需要更新，但这种更新会影响写入性能，所以一般在读密集的OLAP场景中用的多。物化视图的一个特例是OLAP立方体，它是由不同维度组合的网格：</p><p><img class=lazyload src=/svg/loading.min.svg data-src=https://raw.githubusercontent.com/boatrainlsz/my-image-hosting/main/Screenshot_select-area_20231022113546.png data-srcset="https://raw.githubusercontent.com/boatrainlsz/my-image-hosting/main/Screenshot_select-area_20231022113546.png, https://raw.githubusercontent.com/boatrainlsz/my-image-hosting/main/Screenshot_select-area_20231022113546.png 1.5x, https://raw.githubusercontent.com/boatrainlsz/my-image-hosting/main/Screenshot_select-area_20231022113546.png 2x" data-sizes=auto alt=https://raw.githubusercontent.com/boatrainlsz/my-image-hosting/main/Screenshot_select-area_20231022113546.png title=https://raw.githubusercontent.com/boatrainlsz/my-image-hosting/main/Screenshot_select-area_20231022113546.png></p><p>OLAP立方体可以推广到 $n$ 维，比如：日期、产品、商店、客户。</p></div><div class=post-footer id=post-footer><div class=post-info><div class=post-info-line><div class=post-info-mod><span>更新于 2023-10-21</span></div><div class=post-info-license></div></div><div class=post-info-line><div class=post-info-md></div><div class=post-info-share><span></span></div></div></div><div class=post-info-more><section class=post-tags><i class="fas fa-tags fa-fw"></i>&nbsp;<a href=/tags/%E6%95%B0%E6%8D%AE%E5%AF%86%E9%9B%86%E5%9E%8B%E5%BA%94%E7%94%A8%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/>数据密集型应用系统设计</a>,&nbsp;<a href=/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/>读书笔记</a></section><section><span><a href=javascript:void(0); onclick=window.history.back()>返回</a></span>&nbsp;|&nbsp;<span><a href=/>主页</a></span></section></div><div class=post-nav><a href=/posts/ddia/ch09-consistency-and-concensus/ class=prev rel=prev title=《数据密集型应用系统设计》第9章-一致性与共识><i class="fas fa-angle-left fa-fw"></i>《数据密集型应用系统设计》第9章-一致性与共识</a>
<a href=/posts/ddia/ch06-partitioning/ class=next rel=next title=《数据密集型应用系统设计》第6章-数据分区>《数据密集型应用系统设计》第6章-数据分区<i class="fas fa-angle-right fa-fw"></i></a></div></div><div id=comments><div id=utterances></div><noscript>Please enable JavaScript to view the comments powered by <a href=https://utteranc.es/>Utterances</a>.</noscript></div></article></div></main><footer class=footer><div class=footer-container><div class=footer-line>由 <a href=https://gohugo.io/ target=_blank rel="noopener noreffer" title="Hugo 0.121.2">Hugo</a> 强力驱动 | 主题 - <a href=https://github.com/dillonzq/LoveIt target=_blank rel="noopener noreffer" title="LoveIt 0.2.10"><i class="far fa-kiss-wink-heart fa-fw"></i> LoveIt</a></div><div class=footer-line><i class="far fa-copyright fa-fw"></i><span itemprop=copyrightYear>2024</span><span class=author itemprop=copyrightHolder>&nbsp;<a href=/ target=_blank>boatrain</a></span></div></div></footer></div><div id=fixed-buttons><a href=# id=back-to-top class=fixed-button title=回到顶部><i class="fas fa-arrow-up fa-fw"></i>
</a><a href=# id=view-comments class=fixed-button title=查看评论><i class="fas fa-comment fa-fw"></i></a></div><link rel=stylesheet href=/lib/lightgallery/lightgallery.min.css><link rel=stylesheet href=/lib/katex/katex.min.css><script type=text/javascript src=/lib/smooth-scroll/smooth-scroll.min.js></script><script type=text/javascript src=/lib/lazysizes/lazysizes.min.js></script><script type=text/javascript src=/lib/lightgallery/lightgallery.min.js></script><script type=text/javascript src=/lib/lightgallery/lg-thumbnail.min.js></script><script type=text/javascript src=/lib/lightgallery/lg-zoom.min.js></script><script type=text/javascript src=/lib/clipboard/clipboard.min.js></script><script type=text/javascript src=/lib/katex/katex.min.js></script><script type=text/javascript src=/lib/katex/auto-render.min.js></script><script type=text/javascript>window.config={code:{copyTitle:"复制到剪贴板",maxShownLines:10},comment:{utterances:{darkTheme:"github-dark",issueTerm:"pathname",label:"Comment",lightTheme:"github-light",repo:"boatrainlsz/blog-comment"}},lightGallery:{actualSize:!1,exThumbImage:"data-thumbnail",hideBarsDelay:2e3,selector:".lightgallery",speed:400,thumbContHeight:80,thumbWidth:80,thumbnail:!0},math:{delimiters:[{display:!0,left:"$$",right:"$$"},{display:!0,left:"\\[",right:"\\]"},{display:!1,left:"$",right:"$"},{display:!1,left:"\\(",right:"\\)"}],strict:!1}}</script><script type=text/javascript src=/js/theme.min.js></script><script type=text/javascript>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-SLGEHM7PTD")</script><script type=text/javascript src="https://www.googletagmanager.com/gtag/js?id=G-SLGEHM7PTD" async></script></body></html>