<!doctype html><html lang=zh-CN><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=robots content="noodp"><meta http-equiv=X-UA-Compatible content="IE=edge, chrome=1"><title>《数据密集型应用系统设计》第6章-数据分区 - boatrain的博客</title><meta name=Description content="《数据密集型应用系统设计》第6章-数据分区"><meta property="og:title" content="《数据密集型应用系统设计》第6章-数据分区">
<meta property="og:description" content="《数据密集型应用系统设计》第6章-数据分区"><meta property="og:type" content="article"><meta property="og:url" content="https://boatrainlsz.github.io/posts/ddia/ch06-partitioning/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-01-06T20:24:01+08:00"><meta property="article:modified_time" content="2024-01-06T20:24:01+08:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="《数据密集型应用系统设计》第6章-数据分区"><meta name=twitter:description content="《数据密集型应用系统设计》第6章-数据分区"><meta name=twitter:site content="@boatrain666"><meta name=application-name content="boatrain的博客"><meta name=apple-mobile-web-app-title content="boatrain的博客"><link rel="shortcut icon" type=image/x-icon href=/favicon.ico><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=manifest href=/site.webmanifest><link rel=canonical href=https://boatrainlsz.github.io/posts/ddia/ch06-partitioning/><link rel=prev href=https://boatrainlsz.github.io/posts/ddia/ch03-storage-and-retrieval/><link rel=stylesheet href=/lib/normalize/normalize.min.css><link rel=stylesheet href=/css/style.min.css><link rel=stylesheet href=/lib/fontawesome-free/all.min.css><link rel=stylesheet href=/lib/animate/animate.min.css><script type=application/ld+json>{"@context":"http://schema.org","@type":"BlogPosting","headline":"《数据密集型应用系统设计》第6章-数据分区","inLanguage":"zh-CN","mainEntityOfPage":{"@type":"WebPage","@id":"https:\/\/boatrainlsz.github.io\/posts\/ddia\/ch06-partitioning\/"},"genre":"posts","keywords":"数据密集型应用系统设计, 读书笔记","wordcount":1501,"url":"https:\/\/boatrainlsz.github.io\/posts\/ddia\/ch06-partitioning\/","datePublished":"2024-01-06T20:24:01+08:00","dateModified":"2024-01-06T20:24:01+08:00","publisher":{"@type":"Organization","name":"boatrain"},"author":{"@type":"Person","name":"boatrain"},"description":"《数据密集型应用系统设计》第6章-数据分区"}</script></head><body header-desktop header-mobile><script type=text/javascript>(window.localStorage&&localStorage.getItem("theme")?localStorage.getItem("theme")==="dark":""==="auto"?window.matchMedia("(prefers-color-scheme: dark)").matches:""==="dark")&&document.body.setAttribute("theme","dark")</script><div id=mask></div><div class=wrapper><header class=desktop id=header-desktop><div class=header-wrapper><div class=header-title><a href=/ title=boatrain的博客>boatrain的博客</a></div><div class=menu><div class=menu-inner><a class=menu-item href=/posts/>文章 </a><a class=menu-item href=/tags/>标签 </a><a class=menu-item href=/categories/>分类 </a><a class=menu-item href=/search/><i class='fas fa-fw fa-search'></i> 搜索 </a><span class="menu-item delimiter"></span><a href=javascript:void(0); class="menu-item theme-switch" title=切换主题>
<i class="fas fa-adjust fa-fw"></i></a></div></div></div></header><header class=mobile id=header-mobile><div class=header-container><div class=header-wrapper><div class=header-title><a href=/ title=boatrain的博客>boatrain的博客</a></div><div class=menu-toggle id=menu-toggle-mobile><span></span><span></span><span></span></div></div><div class=menu id=menu-mobile><a class=menu-item href=/posts/ title>文章</a><a class=menu-item href=/tags/ title>标签</a><a class=menu-item href=/categories/ title>分类</a><a class=menu-item href=/search/ title><i class='fas fa-fw fa-search'></i>搜索</a><a href=javascript:void(0); class="menu-item theme-switch" title=切换主题>
<i class="fas fa-adjust fa-fw"></i></a></div></div></header><div class="search-dropdown desktop"><div id=search-dropdown-desktop></div></div><div class="search-dropdown mobile"><div id=search-dropdown-mobile></div></div><main class=main><div class=container><div class=toc id=toc-auto><h2 class=toc-title>目录</h2><div class=toc-content id=toc-content-auto></div></div><article class="page single"><h1 class="single-title animated flipInX">《数据密集型应用系统设计》第6章-数据分区</h1><div class=post-meta><div class=post-meta-line><span class=post-author><a href=/ title=Author rel=author class=author><i class="fas fa-user-circle fa-fw"></i>boatrain</a></span></div><div class=post-meta-line><i class="far fa-calendar-alt fa-fw"></i>&nbsp;<time datetime=2024-01-06>2024-01-06</time>&nbsp;<i class="fas fa-pencil-alt fa-fw"></i>&nbsp;约 1501 字&nbsp;
<i class="far fa-clock fa-fw"></i>&nbsp;预计阅读 3 分钟&nbsp;</div></div><div class="details toc" id=toc-static kept><div class="details-summary toc-title"><span>目录</span>
<span><i class="details-icon fas fa-angle-right"></i></span></div><div class="details-content toc-content" id=toc-content-static><nav id=TableOfContents><ul><li><ul><li><a href=#分区的定义>分区的定义</a></li><li><a href=#复制replication和分区partitioning的组合使用>复制(Replication)和分区(Partitioning)的组合使用</a></li><li><a href=#分区的倾斜问题>分区的倾斜问题</a></li><li><a href=#二级索引的分区问题>二级索引的分区问题</a></li></ul></li></ul></nav></div></div><div class=content id=content><h3 id=分区的定义>分区的定义</h3><p>每一条记录只属于某一个特定分区，查询可能会跨分区。</p><h3 id=复制replication和分区partitioning的组合使用>复制(Replication)和分区(Partitioning)的组合使用</h3><p>每个节点同时充当某些分区的leader和其他分区的follower：
<img class=lazyload src=/svg/loading.min.svg data-src=https://raw.githubusercontent.com/boatrainlsz/my-image-hosting/main/Screenshot_select-area_20240106204117.png data-srcset="https://raw.githubusercontent.com/boatrainlsz/my-image-hosting/main/Screenshot_select-area_20240106204117.png, https://raw.githubusercontent.com/boatrainlsz/my-image-hosting/main/Screenshot_select-area_20240106204117.png 1.5x, https://raw.githubusercontent.com/boatrainlsz/my-image-hosting/main/Screenshot_select-area_20240106204117.png 2x" data-sizes=auto alt=https://raw.githubusercontent.com/boatrainlsz/my-image-hosting/main/Screenshot_select-area_20240106204117.png title=https://raw.githubusercontent.com/boatrainlsz/my-image-hosting/main/Screenshot_select-area_20240106204117.png></p><h3 id=分区的倾斜问题>分区的倾斜问题</h3><p>分区不均匀，会导致某些分区节点承担更多的负载。</p><h4 id=使用区间缓解倾斜问题>使用区间缓解倾斜问题</h4><p>比如如下的书架，共有12卷，分区1存放A和B开头的key，分区12包含T、U、V、X、Y、Z开头的key。分区内再按照key排序，这样一来便能支持区间查询。
<img class=lazyload src=/svg/loading.min.svg data-src=https://raw.githubusercontent.com/boatrainlsz/my-image-hosting/main/Screenshot_select-area_20240106205006.png data-srcset="https://raw.githubusercontent.com/boatrainlsz/my-image-hosting/main/Screenshot_select-area_20240106205006.png, https://raw.githubusercontent.com/boatrainlsz/my-image-hosting/main/Screenshot_select-area_20240106205006.png 1.5x, https://raw.githubusercontent.com/boatrainlsz/my-image-hosting/main/Screenshot_select-area_20240106205006.png 2x" data-sizes=auto alt=https://raw.githubusercontent.com/boatrainlsz/my-image-hosting/main/Screenshot_select-area_20240106205006.png title=https://raw.githubusercontent.com/boatrainlsz/my-image-hosting/main/Screenshot_select-area_20240106205006.png></p><p>但是这个方法容易产生热点问题，如果key是时间戳，则分区存储的是某一个时间范围内的数据，比如每一天对应一个分区。这样导致当天的分区总是成为写操作的热点。可以通过细化分区的维度来解决，比如分区的key改为传感器名称+时间，这样当多个传感器处于活动状态时，则负载能较好地均匀分布。</p><h4 id=基于hash分区>基于hash分区</h4><p>优秀的hash函数能很好地处理倾斜问题：
<img class=lazyload src=/svg/loading.min.svg data-src=https://raw.githubusercontent.com/boatrainlsz/my-image-hosting/main/Screenshot_select-area_20240106205627.png data-srcset="https://raw.githubusercontent.com/boatrainlsz/my-image-hosting/main/Screenshot_select-area_20240106205627.png, https://raw.githubusercontent.com/boatrainlsz/my-image-hosting/main/Screenshot_select-area_20240106205627.png 1.5x, https://raw.githubusercontent.com/boatrainlsz/my-image-hosting/main/Screenshot_select-area_20240106205627.png 2x" data-sizes=auto alt=https://raw.githubusercontent.com/boatrainlsz/my-image-hosting/main/Screenshot_select-area_20240106205627.png title=https://raw.githubusercontent.com/boatrainlsz/my-image-hosting/main/Screenshot_select-area_20240106205627.png></p><p>hash分区的缺点在于丧失了区间查询的特性，因为相邻的key，hash后会分散在不同的分区。一些数据库的处理方法如下：</p><ol><li>MongoDB的哈希分区模式，区间查询会发送到所有分区上。</li><li>Riak、Couchbase、Voldemort直接就不支持区间查询。</li><li>Cassandra做了折中，可以声明一个表的复合主键key1+key2+&mldr;+keyN，只有key1可用来hash分区，而其他key用作组合索引来在SSTable中对数据排序。因此，Cassandra不支持在第一列上区间查询。当确定第一列的值后，就可以对其他列进行区间查询。</li></ol><h4 id=极端情况下的倾斜问题>极端情况下的倾斜问题</h4><p>哈希分区可以减轻热点，但无法完全避免。当所有的读写操作都是针对同一个key，则所有请求都会被路由到同一个分区。比如<a href=https://m.huanqiu.com/article/9CaKrnK5tC8 target=_blank rel="noopener noreffer">鹿晗公布恋情导致微博瘫痪</a>。这种问题无法在数据层面解决，只能在应用层自行处理。比如当识别出热点key后，就在key的开头或者结尾增加一个随机数，再进行hash，从而分配到不同的分区上。</p><h3 id=二级索引的分区问题>二级索引的分区问题</h3><p>上面讨论的都是key-value的分区，一个key可以唯一标识一条记录，自然可以用key来分区，但是二级索引不具有唯一性。比如一张Car表：(id,name,color)，查询所有红颜色的汽车，color就是二级索引。针对二级索引的分区，主要有以下两种方案。</p><h4 id=基于文档document分区>基于文档(Document)分区</h4><p>比如一个汽车数据库，根据id分区：0-499为分区0，500-999为分区1。每当一辆红色汽车添加到数据库中，相应的二级索引条目"color:red"也会更新：把汽车的id添加到文档中。
<img class=lazyload src=/svg/loading.min.svg data-src=https://raw.githubusercontent.com/boatrainlsz/my-image-hosting/main/Screenshot_select-area_20240106212044.png data-srcset="https://raw.githubusercontent.com/boatrainlsz/my-image-hosting/main/Screenshot_select-area_20240106212044.png, https://raw.githubusercontent.com/boatrainlsz/my-image-hosting/main/Screenshot_select-area_20240106212044.png 1.5x, https://raw.githubusercontent.com/boatrainlsz/my-image-hosting/main/Screenshot_select-area_20240106212044.png 2x" data-sizes=auto alt=https://raw.githubusercontent.com/boatrainlsz/my-image-hosting/main/Screenshot_select-area_20240106212044.png title=https://raw.githubusercontent.com/boatrainlsz/my-image-hosting/main/Screenshot_select-area_20240106212044.png></p><p>这样一来，每个分区各自独立负责自己的二级索引，而不关心其他分区中的数据。增删改时，只需要处理目标id所在的那个分区即可。因此文档分区索引也被称为本地索引。而查询就不一样了，需要查询所有的分区，然后合并结果。这种查询模式被称为scatter/gather。它的缺点显而易见，查询延迟大。</p><h4 id=基于词条term分区>基于词条(Term)分区</h4><p>与基于文档(Document)分区构建的本地索引不同，基于词条(Term)分区构建的是全局索引。同时，为了避免单点故障，全局索引本身也需要进行分区：
<img class=lazyload src=/svg/loading.min.svg data-src=https://raw.githubusercontent.com/boatrainlsz/my-image-hosting/main/Screenshot_select-area_20240106213105.png data-srcset="https://raw.githubusercontent.com/boatrainlsz/my-image-hosting/main/Screenshot_select-area_20240106213105.png, https://raw.githubusercontent.com/boatrainlsz/my-image-hosting/main/Screenshot_select-area_20240106213105.png 1.5x, https://raw.githubusercontent.com/boatrainlsz/my-image-hosting/main/Screenshot_select-area_20240106213105.png 2x" data-sizes=auto alt=https://raw.githubusercontent.com/boatrainlsz/my-image-hosting/main/Screenshot_select-area_20240106213105.png title=https://raw.githubusercontent.com/boatrainlsz/my-image-hosting/main/Screenshot_select-area_20240106213105.png>
上面的示例中，有两个二级索引：color、make(制造商)。a-r开头的color索引在分区0，s-z开头的color索引则在分区1，make索引也被分区。这种方案的优点在于读取很快(图中的实线)，只需要查询二级索引的分区就能得到所有的主键id。然而缺点就是写入速度慢(图中的虚线)，因为单条记录的更新可能会涉及到多个二级索引，而二级索引分区又有可能位于不同的节点上，从而导致写放大，同时也需要分布式事务的支持。</p></div><div class=post-footer id=post-footer><div class=post-info><div class=post-info-line><div class=post-info-mod><span>更新于 2024-01-06</span></div><div class=post-info-license></div></div><div class=post-info-line><div class=post-info-md></div><div class=post-info-share><span></span></div></div></div><div class=post-info-more><section class=post-tags><i class="fas fa-tags fa-fw"></i>&nbsp;<a href=/tags/%E6%95%B0%E6%8D%AE%E5%AF%86%E9%9B%86%E5%9E%8B%E5%BA%94%E7%94%A8%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/>数据密集型应用系统设计</a>,&nbsp;<a href=/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/>读书笔记</a></section><section><span><a href=javascript:void(0); onclick=window.history.back()>返回</a></span>&nbsp;|&nbsp;<span><a href=/>主页</a></span></section></div><div class=post-nav><a href=/posts/ddia/ch03-storage-and-retrieval/ class=prev rel=prev title=《数据密集型应用系统设计》第3章-数据存储与检索><i class="fas fa-angle-left fa-fw"></i>《数据密集型应用系统设计》第3章-数据存储与检索</a></div></div><div id=comments><div id=utterances></div><noscript>Please enable JavaScript to view the comments powered by <a href=https://utteranc.es/>Utterances</a>.</noscript></div></article></div></main><footer class=footer><div class=footer-container><div class=footer-line>由 <a href=https://gohugo.io/ target=_blank rel="noopener noreffer" title="Hugo 0.121.2">Hugo</a> 强力驱动 | 主题 - <a href=https://github.com/dillonzq/LoveIt target=_blank rel="noopener noreffer" title="LoveIt 0.2.10"><i class="far fa-kiss-wink-heart fa-fw"></i> LoveIt</a></div><div class=footer-line><i class="far fa-copyright fa-fw"></i><span itemprop=copyrightYear>2024</span><span class=author itemprop=copyrightHolder>&nbsp;<a href=/ target=_blank>boatrain</a></span></div></div></footer></div><div id=fixed-buttons><a href=# id=back-to-top class=fixed-button title=回到顶部><i class="fas fa-arrow-up fa-fw"></i>
</a><a href=# id=view-comments class=fixed-button title=查看评论><i class="fas fa-comment fa-fw"></i></a></div><link rel=stylesheet href=/lib/lightgallery/lightgallery.min.css><link rel=stylesheet href=/lib/katex/katex.min.css><script type=text/javascript src=/lib/smooth-scroll/smooth-scroll.min.js></script><script type=text/javascript src=/lib/lazysizes/lazysizes.min.js></script><script type=text/javascript src=/lib/lightgallery/lightgallery.min.js></script><script type=text/javascript src=/lib/lightgallery/lg-thumbnail.min.js></script><script type=text/javascript src=/lib/lightgallery/lg-zoom.min.js></script><script type=text/javascript src=/lib/clipboard/clipboard.min.js></script><script type=text/javascript src=/lib/katex/katex.min.js></script><script type=text/javascript src=/lib/katex/auto-render.min.js></script><script type=text/javascript>window.config={code:{copyTitle:"复制到剪贴板",maxShownLines:10},comment:{utterances:{darkTheme:"github-dark",issueTerm:"pathname",label:"Comment",lightTheme:"github-light",repo:"boatrainlsz/blog-comment"}},lightGallery:{actualSize:!1,exThumbImage:"data-thumbnail",hideBarsDelay:2e3,selector:".lightgallery",speed:400,thumbContHeight:80,thumbWidth:80,thumbnail:!0},math:{delimiters:[{display:!0,left:"$$",right:"$$"},{display:!0,left:"\\[",right:"\\]"},{display:!1,left:"$",right:"$"},{display:!1,left:"\\(",right:"\\)"}],strict:!1}}</script><script type=text/javascript src=/js/theme.min.js></script><script type=text/javascript>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-SLGEHM7PTD")</script><script type=text/javascript src="https://www.googletagmanager.com/gtag/js?id=G-SLGEHM7PTD" async></script></body></html>